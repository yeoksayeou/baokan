<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Newspaper Headline Search (Cloudflare D1 + FTS)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .highlight { background-color: yellow; font-weight: bold; }
        #loading-indicator { display: none; }
        #no-results { display: none; }
        #error-message { display: none; color: red; text-align: center; background-color: #fee2e2; padding: 1rem; border-radius: 0.375rem; margin-bottom: 1rem; }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="container mx-auto max-w-5xl p-4 sm:p-6 md:p-8">
        <h1 class="text-2xl sm:text-3xl font-bold mb-6 text-center text-gray-700">Newspaper Headline Search</h1>

        <div class="bg-white p-4 sm:p-6 rounded-lg shadow-md mb-6 flex flex-col md:flex-row gap-4 items-center justify-between">
            <div class="flex-grow w-full md:w-auto">
                 <input type="search" id="search-input" placeholder="Search headlines (using FTS)..." class="w-full px-4 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent transition duration-150 ease-in-out" oninput="handleSearchInput()">
            </div>

            <div class="flex items-center gap-2 w-full md:w-auto">
                <label for="results-per-page" class="font-semibold text-gray-600 whitespace-nowrap">Results:</label>
                <select id="results-per-page" class="border border-gray-300 rounded-md px-3 py-2 focus:outline-none focus:ring-1 focus:ring-blue-500" onchange="handleResultsPerPageChange()">
                    <option value="30">30</option>
                    <option value="50">50</option>
                    <option value="100">100</option>
                    <option value="200">200</option>
                    <option value="500">500</option>
                </select>
            </div>
        </div>

        <div id="loading-indicator" class="text-center py-4 text-gray-500"> Searching... </div>
        <div id="error-message" class="text-center py-4 text-red-600 bg-red-100 rounded-md shadow-md"></div>
        <div id="no-results" class="text-center py-4 text-gray-500 bg-white p-4 rounded-lg shadow-md"> No headlines found matching your search criteria. </div>

        <div id="results-area" class="space-y-3"></div>
        <div id="pagination-area" class="mt-6 flex justify-center items-center space-x-2"></div>
    </div>

    <script>
        // --- Global Variables ---
        let currentPage = 1;
        let resultsPerPage = 30;
        let currentQuery = '';
        let totalResults = 0;
        let searchTimeout = null;
        let currentSearchController = null; // To abort previous fetches

        // --- DOM Elements ---
        const searchInput = document.getElementById('search-input');
        const resultsArea = document.getElementById('results-area');
        const paginationArea = document.getElementById('pagination-area');
        const resultsPerPageSelect = document.getElementById('results-per-page');
        const loadingIndicator = document.getElementById('loading-indicator');
        const noResultsMessage = document.getElementById('no-results');
        const errorMessageDiv = document.getElementById('error-message');

        // --- Core Functions ---

        /**
         * Fetches search results from the Cloudflare Worker API.
         */
        async function performSearch(page = 1) {
            currentQuery = searchInput.value.trim();
            currentPage = page;
            resultsPerPage = parseInt(resultsPerPageSelect.value, 10);

            console.log(`Searching for: "${currentQuery}", Page: ${currentPage}, Limit: ${resultsPerPage}`);

            // Abort any previous ongoing search request
            if (currentSearchController) {
                currentSearchController.abort();
            }
            currentSearchController = new AbortController();
            const signal = currentSearchController.signal;

            loadingIndicator.style.display = 'block';
            resultsArea.innerHTML = ''; // Clear previous results
            paginationArea.innerHTML = ''; // Clear pagination
            noResultsMessage.style.display = 'none';
            errorMessageDiv.style.display = 'none'; // Hide errors

            const apiUrl = `/api/search?q=${encodeURIComponent(currentQuery)}&limit=${resultsPerPage}&page=${currentPage}`;

            try {
                const response = await fetch(apiUrl, { signal }); // Pass the abort signal

                if (!response.ok) {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (parseError) {
                        errorData = { error: `HTTP error ${response.status}: ${response.statusText}` };
                    }
                    // Don't throw generic error if it was just an abort
                    if (signal.aborted) {
                       console.log("Search aborted.");
                       return; // Exit silently
                    }
                    throw new Error(errorData.error || `HTTP error ${response.status}`);
                }

                const data = await response.json();
                console.log("Received data:", data);
                totalResults = data.totalCount || 0;
                displayResults(data.results || []);

            } catch (error) {
                 if (error.name === 'AbortError') {
                     console.log('Fetch aborted');
                     // Don't show error message if fetch was aborted by user action
                     return;
                 }
                console.error('Search fetch error:', error);
                errorMessageDiv.textContent = `Error: ${error.message}`;
                errorMessageDiv.style.display = 'block';
                totalResults = 0;
                displayResults([]); // Clear results visually
            } finally {
                loadingIndicator.style.display = 'none';
                // Clear the controller once fetch is complete or aborted
                if (currentSearchController && currentSearchController.signal === signal) {
                   currentSearchController = null;
                }
            }
        }

        /**
         * Highlights search terms based on FTS results (simple approach).
         * FTS gives relevance, but exact term highlighting might need client-side logic.
         */
        function highlightText(text, query) {
            if (!query || !text) {
                return text;
            }
            // FTS matches based on tokens. Highlighting can be tricky.
            // This basic version highlights individual words from the query.
            const terms = query.split(/\s+/).filter(term => term.length > 0 && term !== 'AND' && term !== 'OR' && term !== 'NOT'); // Ignore FTS operators
             if (terms.length === 0) return text;

             const escapedTerms = terms.map(term => term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
             // Match whole words boundary where possible might be better: `\b(${escapedTerms.join('|')})\b`
             // But for simplicity, we'll stick to basic matching
             const regex = new RegExp(`(${escapedTerms.join('|')})`, 'gi');
             return text.replace(regex, '<span class="highlight">$1</span>');
        }

        /**
         * Displays the current page of search results and pagination controls.
         */
/**
 * Displays the current page of search results and pagination controls.
 * Includes linking the date to the corresponding issue HTML file.
 */
        function displayResults(results) {
            resultsArea.innerHTML = ''; // Clear previous results
            paginationArea.innerHTML = ''; // Clear previous pagination
            noResultsMessage.style.display = 'none'; // Hide no results message

            if (errorMessageDiv.style.display !== 'none') {
                // If there was an error, don't show "no results"
                return;
            }

            if (results.length === 0) {
                if (currentQuery !== '') { // Only show if there was a search term
                    noResultsMessage.style.display = 'block';
                }
                return;
            }

            // Create and append result elements
            results.forEach(item => {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'bg-white p-4 rounded-md shadow-sm border border-gray-200';
                const highlightedHeadline = highlightText(item.headline, currentQuery);

                // --- Link Generation Logic ---
                let dateDisplay = 'Date: N/A'; // Default if date is missing
                if (item.issue_date) {
                    try {
                        // Assuming item.issue_date is 'YYYY-MM-DD'
                        const year = item.issue_date.substring(0, 4);
                        // Convert 'YYYY-MM-DD' to 'YYYY.MM.DD' for display and filename
                        const displayDate = item.issue_date.replace(/-/g, '.');
                        // Construct the link path
                        const linkPath = `/${year}/${displayDate}.html`;
                        // Create the link HTML
                        dateDisplay = `Date: <a href="${linkPath}" target="_blank" class="text-blue-600 hover:text-blue-800 hover:underline">${displayDate}</a>`;
                    } catch (e) {
                        console.error("Error formatting date/link:", e);
                        // Fallback to plain text if formatting fails
                        dateDisplay = `Date: ${item.issue_date}`;
                    }
                }
                // --- End Link Generation Logic ---

                resultDiv.innerHTML = `
                    <h3 class="text-lg font-semibold text-blue-700 mb-1">${highlightedHeadline}</h3>
                    <div class="text-sm text-gray-500">
                        <span>${dateDisplay}</span> | <span>Page: ${item.page ?? 'N/A'}</span> |
                        <span>Length: ${item.length ?? 'N/A'} words</span>
                    </div>
                `;
                resultsArea.appendChild(resultDiv);
            });

            // --- Pagination (remains the same as the previous version) ---
            const totalPages = Math.ceil(totalResults / resultsPerPage);
            if (totalPages > 1) {
                const prevButton = document.createElement('button');
                prevButton.textContent = 'Previous';
                prevButton.className = 'px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition duration-150 ease-in-out';
                prevButton.disabled = currentPage === 1;
                prevButton.onclick = () => {
                    if (currentPage > 1) {
                        performSearch(currentPage - 1);
                        window.scrollTo(0, 0);
                    }
                };
                paginationArea.appendChild(prevButton);

                const pageIndicator = document.createElement('span');
                const startItem = (currentPage - 1) * resultsPerPage + 1;
                const endItem = Math.min(startItem + resultsPerPage - 1, totalResults);
                pageIndicator.textContent = `Showing ${startItem}-${endItem} of ${totalResults} (Page ${currentPage} of ${totalPages})`;
                pageIndicator.className = 'px-4 text-gray-600';
                paginationArea.appendChild(pageIndicator);

                const nextButton = document.createElement('button');
                nextButton.textContent = 'Next';
                nextButton.className = 'px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed transition duration-150 ease-in-out';
                nextButton.disabled = currentPage === totalPages;
                nextButton.onclick = () => {
                    if (currentPage < totalPages) {
                        performSearch(currentPage + 1);
                        window.scrollTo(0, 0);
                    }
                };
                paginationArea.appendChild(nextButton);
            } else if (totalResults > 0) {
                const pageIndicator = document.createElement('span');
                pageIndicator.textContent = `Showing 1-${totalResults} of ${totalResults}`;
                pageIndicator.className = 'px-4 text-gray-600';
                paginationArea.appendChild(pageIndicator);
            }
        }

        // --- Event Handlers ---
        function handleSearchInput() {
             clearTimeout(searchTimeout);
             searchTimeout = setTimeout(() => {
                 performSearch(1); // Start search from page 1
             }, 300); // Debounce
        }

        function handleResultsPerPageChange() {
            // resultsPerPage = parseInt(resultsPerPageSelect.value, 10); // Already set in performSearch
            performSearch(1); // Re-run search from page 1 with new limit
        }

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            resultsPerPage = parseInt(resultsPerPageSelect.value, 10);
            performSearch(1); // Perform initial search (empty query) on load
        });

    </script>

</body>
</html>