<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chinese Periodical Translation Project - About</title>
    <link href="support/fonts/noto-sans.css" rel="stylesheet"> <style>
        :root {
            /* Using Georgia as fallback if Noto Serif SC isn't available */
            --chinese-font: 'Noto Serif SC', 'Georgia', serif;
            --english-font: 'Georgia', serif;
        }

        body {
            font-family: var(--english-font);
            line-height: 1.6;
            color: #333;
            max-width: 800px; /* Adjusted max-width for better readability */
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }

        .container {
            background-color: #fff; /* Add background to container */
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        /* Style the rendered markdown content */
        .content {
            margin-top: 20px;
        }

        .content h1, .content h2, .content h3, .content h4, .content h5, .content h6 {
            color: #2c3e50;
            margin-top: 1.5em;
            margin-bottom: 0.8em;
            line-height: 1.3;
        }

        .content h1 { font-size: 2.2rem; border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
        .content h2 { font-size: 1.8rem; border-bottom: 1px solid #eee; padding-bottom: 0.3em; }
        .content h3 { font-size: 1.5rem; }
        .content h4 { font-size: 1.2rem; }
        .content h5 { font-size: 1.1rem; }
        .content h6 { font-size: 1.0rem; }

        .content p {
            margin-bottom: 1.2em;
        }

        .content a {
            color: #3498db; /* Standard link color */
            text-decoration: none;
        }
        .content a:hover {
            text-decoration: underline;
        }

        .content strong {
            font-weight: bold;
        }

        .content em {
            font-style: italic;
        }

        .content blockquote {
            border-left: 4px solid #ddd;
            padding-left: 15px;
            color: #555;
            margin-left: 0;
            margin-right: 0;
            margin-bottom: 1.2em;
            font-style: italic;
        }

        .content hr {
            border: 0;
            height: 1px;
            background-color: #ddd;
            margin: 2em 0;
        }

        /* Ensure code blocks/inline code look distinct if added later */
        .content code {
            background-color: #f0f0f0;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: 'Courier New', Courier, monospace;
            font-size: 0.9em;
        }
        .content pre code {
            display: block;
            padding: 1em;
            overflow-x: auto;
        }


        footer {
            margin-top: 40px; /* Reduced margin */
            text-align: center;
            font-size: 0.9rem;
            color: #7f8c8d;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }

        footer a {
            color: #7f8c8d; /* Match footer text color */
            text-decoration: none;
        }
        footer a:hover {
            text-decoration: underline;
        }

        /* Hide the raw markdown content */
        .raw-markdown {
            display: none; /* This hides the content */
        }

        @media (max-width: 768px) {
            body {
                padding: 15px;
            }
            .container {
                padding: 20px;
            }
            .content h1 { font-size: 1.8rem; }
            .content h2 { font-size: 1.5rem; }
            .content h3 { font-size: 1.3rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content" id="rendered-content">
            <p>Loading content...</p>
        </div>
    </div>

    <footer>
        <p><a href="index.html">Project Home</a> | Project <a href="https://github.com/yeoksayeou/baokan">Repository</a> </p>
    </footer>

    <div class="raw-markdown" id="raw-markdown">
# Chinese Translated Periodicals Archive

Welcome to this project, an experiment to use large language models (generative AI) to produce, at large scale, translations of the raw text of a selection of issues of a few Chinese periodicals. 

These translations must be treated with care: they have not been checked by a human. Their accuracy must be checked. If you find an article of interest and don't know enough Chinese to check the original yourself, consider trying various other translation tools such as DeepL or Google Translate, or online dictionaries to confirm the content. Also: the Chinese originals are OCRs of original documents and may contain many errors themselves. More technical notes will be added here later.

## 人民日报

The raw text for *The People's Daily* (Renmin ribao) newspaper was found on [this repository](https://github.com/fangj/rmrb). Not much is known about where this raw text came from or how it was extracted from the original newspaper issues. The translations for the newspaper were carried out using Mistral Small 3.1, in April, 2025. Some of the earliest issues were done with Google Gemini 2.0 Flash and included a request to extract named entities, but when switching to Mistral, results of this were less satisfactory and this feature was removed. The translation prompt that was used can be found [here](prompt-rmrb.txt). 

## 申報

The raw text for *Shenbao*, an important Shanghai newspaper was found on [this repository](https://github.com/moss-on-stone/shenbao-txt). Little is known about this source, but it uses a similar issue naming scheme as the scanned issues of the newspaper that can [be found on the Internet Archvie](https://archive.org/details/shenbao-archive). This raw text collection appears to have more OCR errors than *The People's Daily*, with mistaken characters here and there. 

Translation of this was done through Google Gemini Flash 2.0 with a prompt that can be found [here](prompt-shenbao.txt). The texts were long and broken up into many pieces due to occasional experience with corrupted output (input context is huge for this LLM, but output sometimes struggles with longer outputs). It wouldn't be surprising to find that there are issues in there that are missing some articles etc. The thousands of translated articles have not been indexed and matched up with the originals so a different interface was created that allows a user to browse the Chinese and English side by side. Also, given the very large size of each issue, loading many issues into memory, which *The People's Daily* interface does (a month at a time) was not practical for *Shenbao* and all the pages are just flat web pages loaded separately.

## LLM Translations

The translations here are part of an experiment with using LLMs for large scale translations of historical sources. However, these translations suffer from all the usual issues with generative AI: hallucinations, incomplete answers, inconsistent behavior, and of course, the imperfections of a translation performed without human supervision.

*Does the usefulness of these translations outweigh problems they pose? How bad or good are these translations really? What do they struggle with and what do they do well? These are questions I hope that students and researchers will consider as they explore the translations included here.*

Some examples of issues already found:

*Example One:* Some of the *Shenbao* issues seem to have all the article contents translated but not their headlines. Some of these have been fixed, but not all issues have been checked yet. 

*Example Two:* Some *Shenbao* issues look fine and incomplete, but decided to upgrade sub-headings within an article to article headline.

*Example Three:* Most of the 1966-1968 issues of *The People's Daily* decided to not translate the Xinhua information and date at the very beginning of articles. This was only fixed late in the translations when the prompt was updated to emphasize the importance of this information. for those who can read Chinese, they are still visible in the originals.

*Example Four:* In skimming through the files, what appear to be otherwise decent translations will have one key word translated into an English word that certainly matches the original in some contexts but definitely not the one the article is using it for.

*Example Five:* The *Shenbao* issues, which are often very long, were broken up into 7-20 pieces and translated seperately. This reduced the chance that the LLM would return incomplete translations due to the high number of output tokens. However, some pieces came back missing articles, or came back empty, as if the LLM refused to engage with the content. One possibility might be that some of the content of the newspaper (which often describes violence in Shanghai) may have triggered safety barriers for the LLM. 

If you are student who does not know Chinese and you are browsing these articles, any use of them for your research should really take the original for a given article and run it through, ideally, several other online translation engines (DeepL, Google Translate, some more recent LLMs by the time you read this) and compare the different ways the same relevant sentences get translated there. 

## Shortcuts

When viewing an article you can use the left or right arrows on your keyboard to move quickly from one article to another inside a given issue. On a mobile device you can swipe left or right to do the same. If you change view in a *Shenbao* article, you may need to click on the screen before the keyboard shortcuts work again.
       </div>
       

    <script>
        /**
         * Renders basic Markdown to HTML.
         * Handles: H1-H6, Bold, Italic, Links, Blockquotes, Horizontal Rules, Paragraphs.
         * Note: This is a simplified parser and may not handle all edge cases or complex Markdown.
         * For robust parsing, consider using a library like Marked.js or Showdown.js.
         * @param {string} text - The raw Markdown text.
         * @returns {string} - The rendered HTML string.
         */
        function renderBasicMarkdown(text) {
            if (!text) return '';

            let html = text;

            // Process block elements first (headings, blockquotes, HRs) line by line

            // Split into lines for initial block processing
            let lines = html.split('\n');
            let processedLines = [];
            let inBlockquote = false; // Basic handling for multi-line blockquotes

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];

                // Headings (# Heading)
                const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
                if (headingMatch) {
                    const level = headingMatch[1].length;
                    const content = headingMatch[2].trim();
                    processedLines.push(`<h${level}>${content}</h${level}>`);
                    inBlockquote = false; // Exit blockquote if heading starts
                    continue; // Move to next line
                }

                // Horizontal Rules (---, ***, ___)
                if (line.match(/^([-*_]{3,})$/)) {
                    processedLines.push('<hr>');
                    inBlockquote = false; // Exit blockquote
                    continue; // Move to next line
                }

                // Blockquotes (> quote) - Simple multi-line handling
                const blockquoteMatch = line.match(/^>\s?(.*)$/);
                if (blockquoteMatch) {
                    const content = blockquoteMatch[1];
                    if (!inBlockquote) {
                        processedLines.push('<blockquote>');
                        inBlockquote = true;
                    }
                    // Add content, process potential inline elements later
                    processedLines.push(content + '<br>'); // Use <br> for lines within quote
                } else {
                    if (inBlockquote) {
                        processedLines.push('</blockquote>');
                        inBlockquote = false;
                    }
                    // If not a special block element, keep the line for paragraph processing
                    processedLines.push(line);
                }
            }
             // Close blockquote if it's the last element
            if (inBlockquote) {
                 processedLines.push('</blockquote>');
            }


            // Join lines back for further processing
            html = processedLines.join('\n');


            // Process inline elements (Links, Bold, Italic) - Apply these after block structure is set
            // Links ([text](url))
            html = html.replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>');
            // Bold (**text**)
            html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            // Italic (*text*) - Use a more specific regex to avoid conflict with bold
            html = html.replace(/(?<!\*)\*(?!\*)(.*?)(?<!\*)\*(?!\*)/g, '<em>$1</em>');


            // Process paragraphs: group consecutive non-block lines
            const finalHtmlBlocks = [];
            const htmlLines = html.split('\n');
            let currentParagraph = '';

            for (const line of htmlLines) {
                // Check if the line is already a block element
                if (line.trim().startsWith('<h') || line.trim().startsWith('<blockquote') || line.trim() === '<blockquote>' || line.trim() === '</blockquote>' || line.trim().startsWith('<hr')) {
                    // If there's a paragraph buffer, wrap it and add it
                    if (currentParagraph) {
                        finalHtmlBlocks.push(`<p>${currentParagraph.trim()}</p>`);
                        currentParagraph = '';
                    }
                    // Add the existing block element
                    finalHtmlBlocks.push(line);
                } else if (line.trim() === '') {
                     // Blank line: finalize current paragraph if any
                    if (currentParagraph) {
                        finalHtmlBlocks.push(`<p>${currentParagraph.trim()}</p>`);
                        currentParagraph = '';
                    }
                }
                else {
                    // Regular line, add to current paragraph buffer with a space
                    currentParagraph += line + ' ';
                }
            }
             // Add any remaining paragraph content
            if (currentParagraph) {
                finalHtmlBlocks.push(`<p>${currentParagraph.trim()}</p>`);
            }

            // Join all processed blocks
            return finalHtmlBlocks.join('\n');
        }


        // Ensure renderMarkdown is only called once the DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            console.log("DOM fully loaded and parsed");

            // Get the raw markdown element
            const rawMarkdownElement = document.getElementById('raw-markdown');
            const renderedContentElement = document.getElementById('rendered-content');

            if (!rawMarkdownElement) {
                console.error("Error: Element with ID 'raw-markdown' not found.");
                renderedContentElement.innerHTML = "<p>Error: Could not find Markdown source.</p>";
                return;
            }
            if (!renderedContentElement) {
                console.error("Error: Element with ID 'rendered-content' not found.");
                return;
            }

            // Get the raw markdown text content
            // Using textContent is generally reliable here
            const rawMarkdown = rawMarkdownElement.textContent;
            console.log("Raw Markdown:", rawMarkdown); // Log raw markdown for debugging

            if (!rawMarkdown || rawMarkdown.trim() === '') {
                 console.warn("Raw markdown content is empty.");
                 renderedContentElement.innerHTML = "<p>No content to display.</p>";
                 return;
            }

            // Render the markdown to HTML using our custom function
            try {
                const renderedHtml = renderBasicMarkdown(rawMarkdown);
                console.log("Rendered HTML:", renderedHtml); // Log rendered HTML for debugging

                // Update the content div with the rendered HTML
                renderedContentElement.innerHTML = renderedHtml;
            } catch (error) {
                 console.error("Error during Markdown rendering:", error);
                 renderedContentElement.innerHTML = "<p>Error rendering content. Please check the console.</p>";
            }
        });
    </script>
</body>
</html>
